
#论文一种性浏览器能自动化测试平台


##摘要
现在， 智能手机越来越普遍了，智能手机从传统的一种简单的人与人之间的通信工具变成了一种多用途设备。随着安卓只能手机的到来，使用智能手机访问互联网的人的数量将会高速增长。因此手机浏览器在为用户提供良好的浏览体验中扮演了重要的角色。
本文的目标是分析安卓平台上几个主要的手机浏览器的性能。在本文中，展示了几个常见和手机功能相关的参数测试后的结果。通过这个测试，可以发现浏览器最大的不足和缺陷用以提升用户体验。
目前Web浏览器再手持设备上(例如智能手机)可算是一个杀手级的应用了。可惜的是，在手机上web浏览器的体验却不是那么令人满意。尤其是页面加载时间较长， 缓存机制被认为是一个关键性因素。但是， 现有的被动评估研究并不能完成的定义Web Cache的表现。例如很多研究都是放在客户端的实现而不是服务端的配置。而用户的行为非常难以预料，因此很难研究没有被缓存的资源。本文着重强调了这个问题。提出了一个主动型的来全面评估web cache表现的方法。这个方案的关键思想是在一定周期时间内主动的爬下数以百计网站的资源。这样我们就可以发现网站的资源更新历史并且知道网站服务端的Cache配置。


关键字：安卓，浏览器，性能

##ABSTRACT
Nowadays, smart phones are fast becoming ubiquitous. They have evolved from their traditional use of solely being a device for communication between people to a multipurpose device. With the advent of Android smart phones, the number of people accessing the Internet through their mobile phones is on a steep rise. Hence, web browsers play a major role in providing an excellent browsing experience for its users. As such, the objective of this paper is to analyse the performance of five major mobile web browsers available in the android platform. In this paper, we present the results of a study conducted based on several parameters that assess these mobile browsers’ functionalities. Based on this evaluation, we also propose the best among these browsers to further enrich user experience of mobile web browsing along with utmost performance.

Keywords
Android, Browsers, Performance, Mobile, Dolphin, Mozilla Firefox, Skyfire, Opera Mini


#第一章 绪论


##1.1课题背景和来源


最近几年， 使用手机浏览网页的用户正在爆发性增长。随着手机智能化的到来，移动端浏览用户的增加是由于市面上有了越来越多的完整功能移动浏览器。 2011年手机销量出现了显著增长。在IDC主导的一个调查中， 2011年全年出货的手机中， 有31.8%是智能手机。现代典型的智能手机一般都有较高解析度的触摸屏幕和一个能够呈现标准网页的浏览器,而不仅仅是智能渲染针对移动端优化过的网页。同时还具备通过Wi-Fi或3G4G高速访问网络的能力，根据SataCounter的报告，在2012年1月，8.49%的网页访问来自于移动设备。

手机浏览器是运行在手机上的浏览器，可以通过GPRS进行上网浏览互联网内容。手机浏览器是一种用户在手机终端上通过无线通讯网络进行互联网内容浏览的移动互联网工具，其最主要的应用为网页浏览，同时也可以聚集大量的应用，如导航、社区、多媒体影音、天气、股市等，为用户提供全方位的移动互联网服务。
近年来，我国移动互联网发展势头迅猛，手机浏览器战略地位凸显，众多实力雄厚的互联网企业纷纷加大在手机浏览器市场的布局，投入大量的资金和人力，抢占手机浏览器用户入口。
从手机浏览器市场的发展阶段来看，2009年，中国手机浏览器市场处于市场探索初期，手机浏览器厂商通常采用面向用户免费的策略，以此抢占用户市场。该阶段手机浏览器的产业价值链比较短，主要包括开发、运营和用户，并未涉及大量的广告和内容。虽然手机浏览器已成为炙手可热的概念，但手机自带浏览器仍占据一半的移动互联网用户市场。用户下载安装的浏览器，依然有很大的发展空间。
2010-2011年，较具实力的手机浏览器厂商如手机QQ浏览器等纷纷夯实手机浏览器市场的竞争力，而百度、谷歌等厂商也陆续进入手机浏览器市场。手机浏览器市场“预装收取服务费、广告收费、用户使用或增值业务收费”的商业模式将逐步形成。随着手机浏览器用户粘性逐步养成，用户规模将趋于稳定，保守估计，2012年我国第三方手机浏览器活跃用户规模将达3.6亿户。
展望未来，随着三网融合进程的不断推进，广电网、电信网和互联网的网络融合将使手机发展成为具备看电视、语音通信以及网络服务的全能终端，手机浏览器作为手机端重要网络入口的战略地位将进一步提升。同时，国家层面正积极推动物联网发展，未来将有更多具备上网功能的终端出现，跨媒体网络融合的趋势将使手机浏览器获得更多的发展空间。
从技术层面来看，当前手机浏览器市场处于优化用户体验、引导用户需求阶段，长远来看，满足个性化的用户需求将最终成为指导应用软件发展的唯一标准。3G/4G网络的发展将大幅度改善数据传输的速度，是移动互联网实现快速发展的条件，也是“云计算”得以实现的前提。而“云计算”的实现将解除手机终端对用户的束缚，手机应用，尤其是个性化应用将出现爆发式增长，手机浏览器将成为沟通用户与“云”端服务器的重要渠道，手机浏览器的战略地位将无可替代。


市场上移动端手机的使用场景越来越丰富，功能上也正在接近于桌面浏览器。



##1.2课题的目的和意义


移动端浏览器在用户浏览网页时扮演了一个重要角色，由于移动网络访问越来越重要，对于用户来说， 能否在众多浏览器中选择出一个能够给他带来流畅理想体验的浏览器就非常重要。更进一步说， 更好的浏览体验还取决于硬件和软件平台，用户友好的GUI，对新标准的支持和更好的扩展性，从这个角度来说，对于特定的使用场景，不同的浏览器会有不同的结果。

安卓是一个由Google发起的智能手机平台，开放手持设备联盟发表在2007年11月12号发表了Google Android SDK，在其出现的五年后，安卓目前是移动操作系统的领导者，并在在2010-2011年期间仍有244%的增长。一个由Canalys所作的调查显示在2011年，新出货的智能手机有48.8%采用的是安卓操作系统。[[参考文献]](Global%20mobile%20statistics%202012:%20all%20quality%20mobile%20marketing%20research,%20mobile%20Web%20stats,%20ad%20revenue,usage,trends,%20http://mobithinking.com/mobile-marketing-%20tools/latest-mobile-stats%20Last%20accessed%20on%208th%20April%202012)

安卓是开放框架的平台，它又各种不同的开发和调试工具，各种图形处理库，多媒体的支持，当然还有一个强大的浏览器。在安卓中默认浏览器是建立在Webkit引擎之上的，尽管默认的浏览器已经可以满足日常浏览需要，但是如果想要拥有完整的浏览体验，还是有必要去体验其它浏览器的。

目前在安卓市场上有很多选择，有些是我们很熟悉的PC商店的浏览器，Chrome，Firefox， Opera。尽管看起来好像选择面很广，实际上只有为数不多的浏览器被广泛使用，因此我们只关注在安卓平台流行的几个浏览器上，他们是 Firefox，Chrome，Opera，QQ，UC，Android Browser。我们只是列举了在安卓市场上占有率前几名的浏览器。


2015年，移动端互联网应用超PC端已是不争事实，作为移动终端上网入口——手机浏览器，成为各大互联网公司争相抢夺的必争之地。在这样的行业背景下，究竟是哪一款浏览器能够给用户带来更好的浏览体验呢?此次将选取此领域的知名主流产品做一系列评估，希望能够成为用户选择手机浏览器时的参考。

##1.3国内外研究现状



Yu-Doo Kim 和 Il-Young Moon 在2013年提出了一种在测试智能手机上测试执行速度的方案[[参考文献]](Performance%20Analysis%20of%20Web-browsing%20Speed%20in%20Smart%20Mobile%20Devices)。大多数的web站点都是针对与PC机型。针对PC机型的测试可能对移动设备并不是那么有代表性，反而会造成一定的误导。他们的做法是先列出了所有测试浏览器性能的用例， 然后排出专门针对于桌面浏览器的例子。在得到的针对平板电脑，桌面PC和手持移动设别


PhantomCSS来测试css兼容性(不可靠)


##1.3本文研究主要内容
本人在XX公司实习期间， 曾负责浏览器性能自动化测试的工作。在已有的前端测试用例基础上，经过实践开了适合项目的浏览器自动化测试平台。这个浏览器性能测试平台实现了定时自动测试，测试用例管理，测试用例自动执行和测试结果报告的功能， 为项目组的浏览器自动化测试开发提供了一个可行的工程方案。
主要研究工作有： 对相关需求文档进行分析，在已有的测试用例基础上，设计合理的浏览器性能评估自动化测试用例。结合目前前端工程实际情况， 进行自动化测试框架选型， 利用尾触发异步流程解决方案实现异步执行流程控制。使用MongoDB进行数据存储，以及国内新颖的Echarts做数据中展示。综合上述工作，实现了一个测试用例驱动的浏览器性能测试框架， 使用基于浏览器API实现了浏览器性能黑盒测试。
在本篇论文中， 主要目标提出一个浏览器性能评估体系，并且实现一个完整的平台来测试上面提到的几个安卓平台的主流浏览器。浏览器性能评价维度将放在第三章， 测试平台的实现将放在第四章。建立在上面测试案例基础上的测试结果将放在第五章，并给出结果。

#第二章 关键技术分析
##2.1HTML5技术分析与研究
###2.1.1 HTML5概述
HTML5不仅仅是HTML规范的最新版本，它还是一系列用来制作现代富Web内容的相关技术的总称。后面各章将会介绍这些技术，其中最重要的三项技术是HTML5核心规范、CSS（Cascading Style Sheets，层叠样式表）和JavaScript。
HTML5核心规范定义用以标记内容的元素，并明确其含义。CSS可用于控制标记过的内容呈现在用户面前的外貌。JavaScript则可以用来操纵HTML文档的内容以及响应用户的操作，此外要想使用HTML5新增元素的一些为编程目的设计的特性也需要用到JavaScript。
有些人（那些挑剔、执拗、爱钻牛角尖的人）会说HTML5所指的只是HTML元素。别管他们。这些人看不出Web内容的本质所发生的根本性变化。用于网页的各种技术之间的关联已经变得如此紧密，以致于需要通晓这些技术才能制作Web内容。如果只使用HTML元素，不用CSS，这样制作出来的内容会让用户觉得不便阅读。如果用了HTML和CSS，但不用JavaScript，那就无法为用户的操作提供即时反馈，也无法使用HTML5中的一些高级特性。

HTML5的一大改进就是支持在浏览器中直接播放视频和音频文件（也就是说不借助于插件）。这是W3C对插件风靡现象的一种反应。原生（native）多媒体支持再结合其他HTML特性可望大有作为.

HTML5最大的变化之一是添加了canvas元素。这个元素是对插件现象的另一反应，它提供了一个通用的绘图平面，开发人员可以用它完成一些通常用Adobe Flash来完成的任务。这个特性之所以重要，部分原因在于要使用canvas元素就必须用到JavaScript。编程从而成了HTML文档中第一层次的事情，这是一个重大转变。

HTML5引入了一些用来分开元素的含义和内容呈现方式的特性和规则。这是HTML5中的一个重要概念。这个主题在本书中将多次论及，它标志着HTML在走向成熟的道路上又迈上了一个新台阶，反映出制作和使用HTML内容的方式的多样性。这个变化（它逐步体现在之前的HTML版本中）稍稍增加了Web开发者的负担，这是因为开发者需要先标记内容然后再定义其呈现方式。不过有些实用的新改进可以减轻这种负担。

##2.2非关系型数据库
###2.2.1 关系型数据库面临的问题
Web2.0网站的特点就是非常人性化, 用户成为信息的来源, 用户有被动接收互联网到主动创建互联网信息来源, 实现了不同用户之间, 甚至不同网站的信息交互. 如大家所知的QQ空间, 新浪微博等. 然而这些大型网站所用到的关系型数据库之间暴露出很多很多自身难以克服的问题, 主要包括以下几项
1数据库并发负载高
2海量数据存储和访问
3数据库数据越来越大
4事务管理的负担
5关系型数据读写实时性的忽略
6多表关联查询被弱化
###2.2.2.NoSQL
既然关系型数据库在越来越多的场景下暴露了这么多难以克服的问题, 为了解决这类问题, NoSQL数据库应运而生.
NoSQL是菲关系型数据存储广义定义, 此概念在2009 年得到了广泛认同, 也产生了很多个NoSQL了数据库.

| 存储类型     |     NoSQL产品 |   特性   |
| :-------- | --------:| :------: |
| 文档式存储    |   MongoDB |  文档式的存储一般JSON格式来存储数据的, 存储的内容自然也是文档, 这样也就可以对某些字段简历索引, 实现关系数据库的一些功能|
| 列存储    |   HBase Cassandra Hypertable |  按列存储数据,  最大的特点是方便存储结构化的数据, 方便做数据压缩, 针对某一列或者某几列的查询将会有非常大的IO优势|
| 键值式存储 |  Redis Flare  | 通过key快速查询到值, 存储不论键的形式, 照单全收   |
| 对象式存储  | db4o Versant  |  通过类似对象语言的语法操作数据库  以对象的形式存储数据   |
| 图形式存储 |  FlockDB Neo4J | 图形关系的最佳存储形式   |
| XML式存储 |   BakerlyDBXML BaseX  |  高效的存储XML数据, 并支持XML的内部查询语法, 如XQuery Xpath |

相比较关系数据库而言, NoSQL的优势如下
- NoSQL种类繁多, 而且他们都有共同点是, 去掉了关系型数据库的关系特性,  数据库之间没有联系,. 因为面向集合存储, 易于存储对象的型数据, 存储不需要特定表结构, 这样非常容易扩展.
- NoSQL具有非常良好读写性能, 特别是在大数据的情况下, 读写性能表现的非常优秀, 因为它没有关系,  读写操作比较简单
- NoSQL不需要为存储数据建立字段, 一个集合中随时可以存储自定义的数据格式, 而在关系型数据库中, 增加和和删除字段是一个件非常麻烦的事情, 特别是数据量非常的表, 而在NoSQL数据库中可以轻易做到
- NoSQL数据库可以再不影响性能的情况下, 发给长方便的额实现高可用架构, 例如, Cassandra HBase复制模型可以提高可用性



###2.2.3 一个应用较为广泛的的非关系型数据库 MongoDB
NoSQL发展至今,  出现了很多种数据库, 我选择最有名的MOngoDB来作为我的数据库.
MongoDB作为NOSQL中的一种, 自然具备NoSQL的特性--- 数据库无关系的特性, 正因为没有关系 , 所以它非常容易扩展,
下面是一个典型的MongoDB的数据结构
![Alt text](./1448027196720.png)
MongoDB中包含一个或多个集合, 集合是以BSON( Binary Serialized Document Format)数据格式组织起来的文档集合, 例如上图中集合1存储着3个文档对象, 每个文档的数据结格式都不一样 存储不需要固定的表结构, 模式很随意. MongoDB中的集合类似于关系型数据库中的表,一个文档则类似于关系型数据库中的记录.
MongoDB因为没有关系型,  读写性能非常高. 根据官方文档的说明, 即使在数据量的大佛50GB的时候, MongoDB的数据访问速度仍然是MySQL的10倍以上.
例如在关系型数据库中, 需要插入一个人员信息, 人员的信息还包括住址的信息, 那么
我们需要创建两个表,  一个personInfo表,  一个Address表.
而插入一个人员的信息, 需要先在地址表中插入数据,
```sql
insert into Address values (1,'house number', 'distrct', 'cityname');
```
接下来插入人员信息
```sql
insert into personInfo values ('xx', 20, 'male', 1);
```
而查询整个信息, 需要关联两个表
```
select a.name, a.age, a.sex, b.house_number, b.district
from personInfo a, address b
where a.address_no = b.address_no;
```
 然而在MongDB数据库中, 如果需要存储上例中的信息, 这么做就可以了
```
db.personInfo.insert({
  "name":"xx",
  "age": 26,
  "sex": "male",
  "address":{
    "house_number":1,
    "district": "district",
    "ctiy":"cityname"
  }
})
```
查询的时候则是这样 ```db.personInfo.find() ```

##2.3Webkit
首先来了解WebKit。广义上来说，WebKit是一个开源的项目，其前身是来源于KDE的KHTML和KJS[参考文献](http://www.webkit.org/)。该项目专注于网页内容的展示，开发出一流的网页渲染引擎。它不是浏览器，而且也不想成为浏览器。 该项目包含两个部分，第一是WebCore，其中包含了对HTML，CSS等很多W3C规范的实现；第二部分就是狭义上的WebKit，它主要是各个平台的移植并提供相对应的Web接口，也就是WebView或者类似WebView，这些接口提供操作和显示网页的能力。目前使用WebKit的主流的浏览器或者WebView包括Chrome, Safari, QtWebKit, Android Browser以及众多的移动平台的浏览器。

WebKit2相对于狭义上的WebKit而言，它不是WebKit简单的第二个版本，它是一个新的API层，其最主要的变化在于将网页的渲染置于单独的进程，而接口层则在另外一个进程，它们之间通过IPC来通讯[参考文献](http://trac.webkit.org/wiki/WebKit2)。对于接口的调用者来说，中间的IPC和底下的实现是透明的，这样做的好处有很多，一个很明显的好处是，当网页的渲染出现问题时，不会阻碍Web接口的调用者进程，这会在很大程度上解决或者帮助解决浏览器或者这些调用者的稳定性和安全性等问题。

Blink
关注Web和HTML5领域的人最近应该都有了解WebKit项目的重磅消息，那就是Google退出WebKit项目，创建自己的渲染引擎Blink。这其实不能说完全没有先兆，合合分分，纯属正常。其实，之前关于WebKit2，双方的争论就非常的大。Apple希望它可以随便加入和删除代码而无需担心它会破坏其它Ports的代码，这遭到很多人的反对和不满。同时，另一方面，Google有很多新的功能希望加入WebKit中，但是WebKit可能并不认可他们。双方分歧越来越多，终于分道扬镳。

这里面有个误区，就是Google的Blink是一个全新的引擎。其实不是这样，Blink目前就是从WebKit直接复制出一个版本出来，然后将与chromium无关的Ports全部移除掉，将代码结构重新整理，就目前而言，Blink的渲染和WebKit是一样，但是，以后两者将各自走不同的路。这有点类似于之前WebKit从KHTML中复制出来一样，历史总是惊人的相似。

Blink从WebKit继承而来，那么未来它会在哪些方面做改变呢？根据chromium官方的说法，目前大概有两个比较大的，后面应该有更多的改变：

跨进程的iframe(out-of-process iframes)：为iframes内容创建单独的沙箱进程来渲染它们
将DOM移入JavaScript中，这样JavaScript可以更快的访问DOM
今后，Blink会和WebKit差别越来越大，对Web标准支持也不尽相同，

##2.3NodeJS
###2.3.1NodeJS概述
Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。

V8给Chrome浏览器带来了一个强劲的心脏，使得它在浏览器大战中脱颖而出，也使得Ryan Dahl在语言评估中为选择JavaScript增加了一个极大的权重值。这里我们要谈谈Node给JavaScript带来的一个新局面。鉴于Node之前那些不给力的后端JavaScript实现，在性能和编程模型等方面没能达到与其他语言一较高下的程度，这里先撇开不谈，先谈谈Node与浏览器的对比。

Chrome浏览器和Node的组件构成如图所示。我们知道浏览器中除了V8作为JavaScript引擎外，还有一个WebKit布局引擎。 HTML5在发展过程中定义了更多更丰富的API。在实现上，浏览器提供了越来越多的功能暴露给JavaScript和HTML标签。这个愿景美好，但对于前端浏览器的发展现状而言，HTML5标准统一的过程是相对缓慢的。JavaScript作为一门图灵完备的语言，长久以来却限制在浏览器的沙箱中运行，它的能力取决于浏览器中间层提供的支持有多少。

![enter image description here](http://www.ituring.com.cn/figures/2013/Node.js/05.d01z.01.png)


除了HTML、WebKit和显卡这些UI相关技术没有支持外，Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O，这个细节将在第3章中详述。在Node中，JavaScript可以随心所欲地访问本地文件，可以搭建WebSocket服务器端，可以连接数据库，可以如Web Workers一样玩转多进程。如今，JavaScript可以运行在不同的地方，不再继续限制在浏览器中与CSS样式表、DOM树打交道。如果HTTP协议栈是水平面，Node就是浏览器在协议栈另一边的倒影。Node不处理UI，但用与浏览器相同的机制和原理运行。Node打破了过去JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价。

对于前端工程师而言，自己所熟悉的JavaScript如今竟然可以在另一个地方放出异彩，不谈其他原因，仅仅因为好奇，就值得去关注和探究它。

随着Node的出现，关于JavaScript的想象总是无限的。目前，社区已经出现node-webkit这样的项目，这个项目在2012年的沪JS会议上首次介绍给了公众。如同上文提及的关于浏览器的优势和限制，在node-webkit项目中，它将Node中的事件循环和WebKit的事件循环融合在一起，既可以通过它享受HTML、CSS带来的UI构建，也能通过它访问本地资源，将两者的优势整合到一起。桌面应用程序的开发可以完全通过HTML、CSS、JavaScript完成。

###2.3.2Node的特点
作为后端JavaScript的运行平台，Node保留了前端浏览器JavaScript中那些熟悉的接口，没有改写语言本身的任何特性，依旧基于作用域和原型链，区别在于它将前端中广泛运用的思想迁移到了服务器端。下面我们来看看Node相较其他语言的一些特点。
异步I/O

关于异步I/O，向前端工程师解释起来或许会容易一些，因为发起Ajax调用对于前端工程师而言是再熟悉不过的场景了。下面的代码用于发起一个Ajax请求：
![enter image description here](http://www.ituring.com.cn/figures/2013/Node.js/05.d01z.03.png)

事件和回调函数
随着Web 2.0时代的到来，JavaScript在前端担任了更多的职责，事件也得到了广泛的应用。Node不像Rhino那样受Java的影响很大，而是将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。
相比之下，无论在前端还是后端，事件都是常用的。对于其他语言来说，这种俯拾皆是JavaScript的熟悉感觉是基本不会出现的。
事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。
从前面可以看到，回调函数无处不在。这是因为在JavaScript中，我们将函数作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用

单线程
Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。
同样，单线程也有它自身的弱点，这些弱点是学习Node的过程中必须要面对的。积极面对这些弱点，可以享受到Node带来的好处，也能避免潜在的问题，使其得以高效利用。单线程的弱点具体有以下3方面。
- 无法利用多核CPU。
- 错误会引起整个应用退出，应用的健壮性值得考验。
- 大量计算占用CPU导致无法继续调用异步I/O。

跨平台
起初，Node只可以在Linux平台上运行。如果想在Windows平台上学习和使用Node，则必须通过Cygwin或者MinGW。随着Node的发展，微软注意到了它的存在，并投入了一个团队帮助Node实现Windows平台的兼容，在v0.6.0版本发布时，Node已经能够直接在Windows平台上运行了。

###2.3.3 NodeJS应用场景
在Node的推广过程中，无数次有人问起Node的应用场景是什么。如果将所有的脚本语言拿到一处来评判，那么从单线程的角度来说，Node处理I/O的能力是值得竖起拇指称赞的。通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。

I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。


##2.4前端工程化
###2.4.1打包工具介绍
###2.4.2打包工具选择


#第三章 系统需求分析与设计
##3.1测试用例设计思想
###3.1.1浏览器加载资源的过程
Web页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验。简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。先来大致了解一下浏览器都是怎么干活的：
1.用户输入网址（假设是个html页面，并且是第一次访问）
2.DNS解析: 查找域名的 IP 地址
这一步包括 DNS 具体的查找过程，包括：浏览器缓存->系统hosts->本地DNS缓存->ISP的DNS服务器...
目前各大浏览器默认开启了DNS缓存功能, 如果一个域名在这里命中, 将直接发送请求到对应的服务器上
下一步操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
本地的DNS缓存, 操作系统本身也会对DNS做缓存
如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。

3.在知道IP地址之后, 浏览器就可以向 web 服务器发送一个 HTTP 请求
如果服务器设置了重定向,服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）,那么浏览器跟踪重定向地址
4.服务器处理请求
5.服务器返回一个 HTTP 响应
6.浏览器显示解析 HTML
7.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
浏览器发送异步请求


###3.1.2页面渲染的过程
概述
渲染引擎的基本功能: 包括网络，资源加载，DOM树，RenderObject树等. 但是，虽然列举出了这些, 仍给人以零乱的感觉，因为没有一个整体的过程描述它们在这个过程中的位置，它们只是整个渲染引擎工作的一个或者多个步骤而已。 渲染引擎的主要目的就是从一个网页的URL开始，经过一系列的复杂处理过程之后，变成一个可视化的结果，这一过程就是这里所说的页面渲染的基本过程。

所谓的渲染，就是根据描述或者定义构建数学模型，通过模型生成图像的过程。浏览器的渲染引擎就是能够将HTML/CSS/JavaScript转换成图像结果的模块，如下图所示，输入是URL对应的各种资源，输出是可视化的图像。从这里看，非常的简单和容易理解。
![enter image description here](http://img.blog.csdn.net/20130921092025218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWlsYWRvX25qdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

渲染模块
那么渲染引擎提供了哪些功能模块来支持页面渲染的呢？下图是一个渲染引擎所包含的基本功能和它们依赖的一些第三方库。
![enter image description here](http://img.blog.csdn.net/20130921092322593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWlsYWRvX25qdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
从图中大致可以看出，一个渲染引擎大致包括HTML解释器，CSS解释器，布局和JavaScript引擎。下面依次来描述它们： HTML解释器：解释HTML语言的解释器，本质是将HTML文本解释成DOM（文档对象模型）树。 CSS解释器：解释样式表的解释器，其作用是将DOM中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。 布局：DOM之后，需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型。 JavaScript引擎：JavaScript可以修改网页的内容，也能修改CSS的信息，JavaScript引擎解释JavaScript代码并把代码的逻辑和对DOM和CSS的改动信息应用到布局中去，从而改变渲染的结果。 这些模块依赖很多其他的基础模块，这其中包括网络，存储，2D/3D图形，音频视频和图片解码器等。实际上，渲染引擎中还应该包括如何使用这些依赖模块的部分，这部分的工作其实并不少，因为需要使用它们来高效的渲染网页。例如，利用2D/3D图形库来实现高性能的网页绘制和网页的3D渲染，这个实现非常非常的复杂。最后，当然，在最下面，依然少不了操作系统的支持，例如线程支持，文件支持等等。

基本过程
了解模块之后，下面就是这些模块如何组织以达成渲染过程的。一般地，一个典型的渲染过程下图所示，这是渲染引擎的核心过程，一切都是围绕着它来的。 ![enter image description here](http://img.blog.csdn.net/20130921092344312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWlsYWRvX25qdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
下面逐个从左至右来解释上图中的这一过程。这一过程的先后关系由图中的实线箭头表示。左上角开始，首先是网页内容，送到HTML解释器。HTML解释器在解释它后形成DOM树，中间如果遇到JavaScript代码则交给JavaScript引擎去处理。如果页面包含CSS，则交给CSS解释器去解析。当DOM建立的时候，接受来自CSS解释的样式信息，构建一个新的内部绘图模型。该模型由布局模块计算模型内部的各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。 最后解释图中虚线箭头的指向含义。它们表示在渲染过程中，每个阶段可能使用到的其他模块。在网页内容的下载中，需要使用到网络和存储，这个是显而易见地。但计算布局和绘图的时候，需要使用2D/3D的图形模块，同时因为要生成最后的可视化结果，这时候需要开始解码音频视频和图片，同其它内容一起绘制到最后的图像中。 在渲染完成之后，用户可能需要跟渲染的结果进行交互，或者网页自身有动画，一般而言，这会持续的重新渲染过程。这个过程跟上面类似，不再赘述。

###3.1.2浏览器性能测试角度
###3.1.2测试用例框架设计
##3.2CSS兼容性测试原理
##3.3HTMl5兼容性测试原理
HTML5的测试成绩，代表了您的浏览器对即将推出的HTML5标准规范的支持程度。尽管规范尚未最终敲定，但是所有浏览器制造商都已经为浏览器的未来做好了准备。通过这个测试，可以知道您的浏览器有哪部分已经支持了HTML5。同时您还可以对比其他浏览的测试结果。
HTML5测试，并不试图去测试所有HTML5提供的新功能，也没有试图测试其检测每个特征的的功能。尽管有这些不足，我们仍希望通过量化的方式，提供给用户和Web开发人员一个平台，让他们知道哪款浏览器的性能是最好的。
这个分数是通过测试HTML5的众多新的功能计算出来的，每个功能都是很宝贵的。除了使用HTML5规范和其他规范创建W3C HTML工作组，这个测试同时可以为配套的相关草案和规范要点进行打分。这些规范最初是HTML5的一部分，但是现在通过W3C HTML工作组得到了进一步的发展。由于WebGL扩展了HTML5画布元素的一个3D背景，所以没有被W3C开发，但是也是本次测试的一部分。
请知晓，HTML5规范仍属于开发测试阶段，在官方正式定位前可能会出现更改，未来将会增加新的测试点。虽然在现在你的成绩可以达到0，但是这个成绩随时会改变。因为面对未来的挑战，我们仍会增加规范的内容。


##3.3异步处理
###3.3.1 过多嵌套导致的问题
###3.3.2 Promise A+ Async  （两种应用广泛的异步处理方式）
###3.3.3 Flow
##3.4数据库设计
##3.5模块化处理
###3.5.1模块化的优势
###3.5.2AMD 和 CMD  （两种应用广泛的模块化介绍）
##3.6浏览器选择
最有效分类浏览器的做法就是把浏览器分成两大类，传统，全功能的浏览器；另一种就是轻巧的迷你浏览器。完整功能的浏览器倾向于带来更接近于桌面浏览器移动端体验，他们的迷你版本更注重性能和向后的兼容性。本论文主要关注几个全功能移动浏览器和一个迷你浏览器。因此根据下面两个考虑选择了5个安卓平台的浏览器，浏览器的市场占有率和流行程度，这些数据来自于 [[6]](Mobile/Tablet%20Browser%20Market%20Share%20http://netmarketshare.com/browser-market-%20share.aspx?qprid=0&qpcustomd=1%20Last%20accessed%20on%2028th%20March%202012). 因此选择了默认浏览器，Firefox，Chrome， Opera。这些浏览器的版本如下表， 他们均是当前最新版本。

#第四章 测试平台实现
##4.1详细用例实现
###4.1.1DOM测试用例
###4.1.2Cache测试用例
先从HTTP状态分析开始
请求
![Alt text](./1447999113751.png)
响应
【说说HTTP的状态码】
![Alt text](./1447999126152.png)
   说到HTTP响应报文，就不得不提到HTTP状态码，及原因短语。相信大家看完这一小节后，就会很清楚404代表着什么了。
   状态码总共只有三位，第一位表示状态类别，共分五种，我们来依次看一下：
1xx：是进度通知类状态，意思就是说“请求我已经收到了，或你的请求我正在处理”；
2xx：表示“你的请求我已经成功处理了”；
3xx：即重定向，也就是服务器告诉客户端“你要的资源搬家了，你到某某地方再去找他吧”；
4xx：客户端发来的响应报文里有些错误，比如语法错误或请求的资源不存在等；
5xx：服务器端有些问题，已经无法处理完成你的请求了。

   其实常用的状态码并不多，我们把常见的列举在此：
200 OK：客户端请求成功了，客户端要的东西就在响应报文里了；
301 Moved Permanently：客户端啊，你要请求的资源已经永久的搬家了，我把他的新地址放到了Location头部域中了；
302 Moved Temporarily：客户端啊，你要请求的资源临时有事去别的地方了，我把他的位置放到了Location头部域中了，你可以先去那里找他，不过他应该是会回到他自己的家的；
304 Not Modified：客户端啊，你要请求的资源自从上次你请求之后，就再也没有改动过，我想你是应该早就有这个资源了，所以在响应报文的数据部分我也没有再放这个资源。
400 Bad Request：客户端发来的请求报文里有语法错误，服务器端实在看不懂了；
401 Unauthorized：客户端发来的请求不是合法来源的请求，也就是这个客户端是没有被授权的；
403 Forbidden：服务器端顺利收到了客户端的请求，但是因为某些理由，服务器端拒绝为他提供服务；
404 Not Found：客户端要请求的资源不存在，八成是资源地址写错了；
500 Internal Server Error：很遗憾，服务器不能给你提供服务了，服务器内部出现了不可预知的问题了；
502 Bad Gateway：客户端你好，我是请求报文的代理服务器，持有资源的那个服务器在给我发送资源时出问题了；
503 Server Unavailable：服务器现在可能是太忙了，暂时不能给你这个客户端提供服务了，或许稍后会恢复。

   【HTTP版本有几个】

   最早的HTTP版本是0.9，现在已经很少使用了。
   而基于0.9版本改进后的是HTTP1.0版本，对应的RFC编号是1945。
   现在最常用的则是基于1.0版本改进后的HTTP1.1版本，对应的RFC编号是2616，其最大的改进点就是增加了“持久连接”的内容，同时在缓存控制与多级代理方面也有不小的完善。

   【一些高级用法】

   1 HTTP1.1中，我们可以在报文中使用Cache-Control域来控制缓存策略；而在HTTP1.0中则可以使用Pragma域来控制。为了确保达到效果，我们往往会在HTTP报文中同时设置Cache-Control:no-cache和Pragma:no-cache

   2 在请求报文中，我们可以设置Accept头部域来指明客户端希望接受哪些类型的数据，比如Accept:image/gif，则表明客户端希望接收gif图片数据。当然我们可以设置很多种可接受的类型。

   3 在请求报文中，Accept-Charset则是用来设置客户端希望接受的字符集。

   4 在请求报文中，Accept-Encoding则是用来指定客户端希望接受的编码类型。

   5 在请求报文中，Accept-Language是指明客户端希望接受的语言类型，例如Accept-Language:zh-cn，表明客户端希望得到中文的内容

   6 在请求报文中，If-Modified-Since域用作缓存策略。具体的原理是这样的，浏览器本地会缓存一些数据，包括网页、图片等，而且还会同时存储这些缓存数据在服务器端的最后修改时间(Last-Modified)。当浏览器再向服务器端发起这些数据的请求时，会同时把这些数据的最后修改时间通过If-Modified-Since一起传给服务器端，服务器端一旦看到这个头部域，就会先拿这个时间戳和相应资源的最后修改时间比较下，如果相同，就说明这个资源一直以来都没有改动过，于是服务器端就不用再把这个数据重复的传给客户端了，而是直接在响应报文中返回304即可，避免了重复传输带来的带宽消耗。

   7 有些同学会感觉疑惑，为什么Last-Modified和If-Modified-Since域都是存储“最后修改时间”的，有啥区别呢。他俩的区别在于，Last-Modified域是响应报文中使用的，由服务器端发给客户端的；而If-Modified-Since则是用在请求报文中的，由客户端发给服务器端的。这两者都是用绝对时间来表示的，所以存在时间同步的问题。那有没有更好的解决办法呢，请继续往下看：)

   8 为大家隆重推出Etags和If-None-Match这一对兄弟，他俩的关系和“Last-Modified/If-Modified-Since”的关系一样，Etags(Entity Tags)是用于响应报文中的，而If-None-Match是用于请求报文中的。这对兄弟的好处在于，他们不是以绝对时间来判断数据是否被修改过，而是通过数据的某个属性值来判断，例如数据的MD5值，这样就可以很好的避免时间不同步的问题了。(除了If-None-Match外，请求报文的头部域中还可以用If-Match、If-Range来表示希望获取的Etag值)

   9 在响应报文中，可以使用Location头部域来实现重定向，比如更换了域名之后。

   10 在HTTP协议里，除了Etags/if-None-Match，Last-Modified/If-Modified-Since外，还有两对这样的兄弟，其一是Server/User-Agent，Server是服务器端用来亮明身份的，而User-Agent是客户端用来亮明身份的；另一对是Set-Cookie和Cookie，Set-Cookie用于服务器端向客户端设置cookie的，而Cookie则是客户端告诉服务器端自己的cookie的。

   11 在响应报文中，服务器端可以使用Expires域来告诉客户端最多缓存这个数据到什么时间，如果超过这个时间点的话，客户端就不要再缓存这个数据了，而是向服务器端重新发起新的请求。

   12 在响应报文中，服务器端可以使用Set-Cookie头部域向客户端设置cookie。其语法很简单，就是由多个name=value组成的，由分号间隔。例如：

Set-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/
   13 在响应报文中，X-Powered-By头部域表示服务器端使用到的技术名称，例如X-Powered-By: ASP.NET


##4.2html5兼容性测试实现
##4.3CSS3测试实现
##4.3跨域问题
##4.3异步问题解决
##4.4浏览器嗅探
##4.4数据库处理
##4.5定时任务
##4.6Android 唤起应用
##4.7移动端前端问题和解决
##4.8打包工具应用

#第五章 测试结果和分析



#第六章 总结与展望
##6.1总结
##6.2展望












